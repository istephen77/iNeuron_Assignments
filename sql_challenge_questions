CREATE DATABASE IF NOT EXISTS SQL_QUESTION_SETS;
USE SQL_QUESTION_SETS;

-- DATASET - 1
CREATE TABLE IF NOT EXISTS CITY (
ID INT,
`NAME` VARCHAR(17),
COUNTRYCODE VARCHAR(3),
DISTRICT VARCHAR(30),
POPULATION INT);

INSERT IGNORE INTO CITY VALUES (1661, "ROTTERDAM", "NLD", "ZUID-HOLLAND", 593321),
(3878, "SCOTSDALLE","USA","ARIZONA",202705),
(3965,"CORONA","USA","CALIFORNIA",124966),
(3973,"CONCORD","USA","CALIFORNIA",1212780),
(3977,"CAEDAR RAPIDS","USA","LOWA",120758),
(5054,"FAIRFIELD","USA","CALIFORNIA",92256),
(4058,"BOULDER","USA","COLORADO",91238),
(4061,"FALLRIVER","USA","MassachusettS",90555);
INSERT INTO CITY VALUES (7634,"OSAKA","JPN","TOSHIBA",232346)

SELECT * FROM CITY;

-- 1) Query all columns for all American cities in the CITY table with populations larger than 100000.
SELECT * FROM CITY WHERE COUNTRYCODE = "USA" AND POPULATION > 100000;

-- 2) Query the NAME field for all American cities in the CITY table with populations larger than 120000.
SELECT `NAME` FROM CITY WHERE COUNTRYCODE = "USA" AND POPULATION > 120000;

-- 3) Query all columns (attributes) for every row in the CITY table.
SELECT ID, NAME, COUNTRYCODE, DISTRICT, POPULATION FROM CITY;

-- 4) Query all columns for a city in CITY with the ID 1661.
SELECT * FROM CITY WHERE ID = 1661;

-- 5) Query all attributes of every Japanese city in the CITY table. The COUNTRYCODE for Japan is JPN
SELECT * FROM CITY WHERE COUNTRYCODE = "JPN";

-- 6) Query the names of all the Japanese cities in the CITY table. The COUNTRYCODE for Japan is JPN
SELECT `NAME` FROM CITY WHERE COUNTRYCODE = "JPN";

-- DATASET 2
CREATE TABLE IF NOT EXISTS STATION (
ID INT,
CITY VARCHAR(21),
STATE VARCHAR(2),
LAT_N INT,
LONG_W INT
);

INSERT IGNORE INTO STATION VALUES (794, "KISSEE MILLS", "MO", 139, 73),
(824, "LOMA MAR", "CA", 48, 130),
(603, "SANDY HOOK", "CT", 72, 148),
(478, "TIPTON", "IN",33,97),
(619,"ARLINGTON","CO",75,92),
(711, "TURNER","AR",50,101),
(839,"SLIDELL","LA",85,151),
(411,"NIGREET","LA",98,105),
(588,"GLENCOE","KY",46,136),
(665,"CHELSEA","IA",98,59);
INSERT IGNORE INTO STATION VALUES (794, "KISSEE MILLS", "MO", 139, 73);
SELECT * FROM STATION;

--  7) Query a list of CITY and STATE from the STATION table.
SELECT CITY, STATE FROM STATION;

--  8) Query a list of CITY names from STATION for cities that have an even ID number. 
-- Print the results in any order, but exclude duplicates from the answer.
SELECT DISTINCT(CITY) FROM STATION WHERE ID % 2 = 0;

-- 9) Find the difference between the total number of CITY entries in the table and the number of
-- distinct CITY entries in the table.
SELECT (COUNT(CITY) - COUNT_DISTINCT_CITY) AS NETT_CITY_COUNT FROM STATION
CROSS JOIN (
SELECT COUNT(DISTINCT_CITY) AS COUNT_DISTINCT_CITY FROM (
SELECT DISTINCT(CITY) AS DISTINCT_CITY FROM STATION)   AS TEST) AS TEST;

-- 10) Query the two cities in STATION with the shortest and longest CITY names, as well as their
-- respective lengths (i.e.: number of characters in the name). If there is more than one smallest or
-- largest city, choose the one that comes first when ordered alphabetically.
SELECT * FROM STATION;

WITH CTE AS (
SELECT CITY, LENGTH(CITY) AS CITY_LENGTH,
ROW_NUMBER() OVER(ORDER BY LENGTH(CITY) ASC, CITY ASC) AS MIN_LENGTH, 
ROW_NUMBER() OVER(ORDER BY LENGTH(CITY) DESC, CITY DESC) AS MAX_LENGTH
FROM STATION
)
SELECT CITY, CITY_LENGTH FROM CTE WHERE MIN_LENGTH = 1
UNION ALL
SELECT CITY, CITY_LENGTH FROM CTE WHERE MAX_LENGTH = 1;

-- 11) Query the list of CITY names starting with vowels (i.e., a, e, i, o, or u) from STATION. Your result
-- cannot contain duplicates.
SELECT DISTINCT(CITY) AS CITY FROM STATION WHERE SUBSTR(CITY,1,1) IN ('A','E','I','O','U');

-- 12) Query the list of CITY names ending with vowels (a, e, i, o, u) from STATION. Your result cannot
-- contain duplicates.
SELECT DISTINCT(CITY) AS CITY FROM STATION WHERE SUBSTR(CITY,-1,1) IN ('A','E','I','O','U');

-- 13)  Query the list of CITY names from STATION that do not start with vowels. Your result cannot
-- contain duplicates.
SELECT DISTINCT(CITY) AS CITY FROM STATION WHERE SUBSTR(CITY,1,1) NOT IN ('A','E','I','O','U');

-- 14) Query the list of CITY names from STATION that do not end with vowels. Your result cannot contain duplicates.
SELECT DISTINCT(CITY) AS CITY FROM STATION WHERE SUBSTR(CITY,-1,1) NOT IN ('A','E','I','O','U');

-- 15) Query the list of CITY names from STATION that either do not start with vowels or do not end
-- with vowels. Your result cannot contain duplicates.
SELECT DISTINCT(CITY) AS CITY FROM STATION WHERE LEFT(CITY,1) NOT REGEXP 'A|E|I|O|U' OR
RIGHT(CITY,1) NOT REGEXP 'A|E|I|O|U';

SELECT DISTINCT(CITY) AS CITY FROM STATION WHERE CITY NOT REGEXP '^[AEIOU]' OR CITY NOT REGEXP '[AEIOU]$';

-- 16. Query the list of CITY names from STATION that do not start with vowels and do not end with vowels. 
-- Your result cannot contain duplicates
SELECT DISTINCT(CITY) AS CITY FROM STATION WHERE CITY NOT REGEXP '^[AEIOU]' AND CITY NOT REGEXP '[AEIOU]$';

-- DATASET 3
CREATE TABLE IF NOT EXISTS PRODUCT (
PRODUCT_ID INT,
PRODUCT_NAME VARCHAR(30),
UNIT_PRICE INT,
PRIMARY KEY(PRODUCT_ID)
);

CREATE TABLE IF NOT EXISTS SALES (
SALES_ID INT,
PRODUCT_ID INT,
BUYER_ID INT,
SALES_DATE DATE,
QUANTITY INT,
PRICE INT,
FOREIGN KEY(PRODUCT_ID) REFERENCES PRODUCT(PRODUCT_ID)
);

INSERT IGNORE INTO PRODUCT VALUES (1,"S8",1000),
(2,"G4",800),
(3,"IPHONE",1400);

INSERT IGNORE INTO SALES VALUES (1,1,1,"2019-01-21",2,2000),
(1,2,2,"2019-02-17",1,800),
(2,2,3,"2019-06-02",1,800),
(3,3,4,"2019-05-13",2,2800);

SELECT * FROM SALES;
SELECT * FROM PRODUCT;

-- 17) Write a SQL query that reports the products that were only sold in the first quarter of 2019. That is,
-- between 2019-01-01 and 2019-03-31 inclusive.
SELECT P.PRODUCT_ID AS `PRODUCT ID`, P.PRODUCT_NAME AS `PRODUCT NAME` FROM PRODUCT P LEFT OUTER JOIN SALES S
ON (P.PRODUCT_ID = S.PRODUCT_ID)
GROUP BY P.PRODUCT_ID
HAVING SUM(S.SALES_ID BETWEEN '2019-01-01' AND '2019-03-31') = COUNT(S.SALES_ID)

-- DATASET 4
CREATE TABLE IF NOT EXISTS VIEWS (
ARTICLE_ID INT,
AUTHOR_ID INT,
VIEWER_ID INT,
VIEW_DATE DATE
);

INSERT IGNORE INTO VIEWS VALUES (1,3,5,'2019-08-01'),
(1,3,6,'2019-08-02'),
(2,7,7,'2019-08-01'),
(2,7,6,'2019-08-02'),
(4,7,1,'2019-07-22'),
(3,4,4,'2019-07-21'),
(3,4,4,'2019-07-21');

SELECT * FROM VIEWS;

-- 18) Write an SQL query to find all the authors that viewed at least one of their own articles
-- Return the result table sorted by id in ascending order.
SELECT AUTHOR_ID AS `AUTHOR ID` FROM VIEWS WHERE (AUTHOR_ID = VIEWER_ID) >= 1 AND VIEW_DATE GROUP BY AUTHOR_ID
ORDER BY AUTHOR_ID ASC;

--  DATASET 5
CREATE TABLE IF NOT EXISTS DELIVERY (
DELIVERY_ID INT,
CUSTOMER_ID INT,
ORDER_DATE DATE,
CUSTOMER_PREF_DELIVERY_DATE DATE,
PRIMARY KEY(DELIVERY_ID)
);

INSERT IGNORE INTO DELIVERY VALUES (1,1,"2019-08-01","2019-08-02"),
(2,5,"2019-08-02","2019-08-02"),
(3,1,"2019-08-11","2019-08-11"),
(4,3,"2019-08-24","2019-08-26"),
(5,4,"2019-08-21","2019-08-22"),
(6,2,"2019-08-11","2019-08-13");

SELECT * FROM DELIVERY;

-- 19) Write an SQL query to find the percentage of immediate orders in the table, rounded to 2 decimal places

SELECT ROUND(100*D2.IMMEDIATE_ORDER / COUNT(DELIVERY_ID),2) FROM DELIVERY D1,(
SELECT COUNT(ORDER_DATE) AS IMMEDIATE_ORDER FROM DELIVERY WHERE (ORDER_DATE = CUSTOMER_PREF_DELIVERY_DATE)) AS D2;

-- DATASET 6
CREATE TABLE IF NOT EXISTS ADS (
AD_ID INT,
USER_ID INT,
`ACTION` VARCHAR(20),
PRIMARY KEY (AD_ID, USER_ID)
);

INSERT IGNORE INTO ADS VALUES (1,1,"CLICKED"),
(2,2,"CLICKED"),
(3,3,"VIEWED"),
(5,5,"IGNORED"),
(1,7,"IGNORED"),
(2,7,"VIEWED"),
(3,5,"CLICKED"),
(1,4,"VIEWED"),
(2,11,"VIEWED"),
(1,2,"CLICKED");

SELECT * FROM ADS;

-- 20) Write an SQL query to find the ctr of each Ad. Round ctr to two decimal points.
-- Return the result table ordered by ctr in descending order and by ad_id in ascending order in case of a tie.

SELECT AD_ID, 
IFNULL(ROUND(SUM(ACTION = "CLICKED")/SUM(ACTION != "IGNORED")*100, 2), 0) AS CTR FROM ADS
GROUP BY AD_ID ORDER BY CTR DESC, AD_ID;

-- DATASET 7
CREATE TABLE IF NOT EXISTS EMPLOYEE (
EMPLOYEE_ID INT,
TEAM_ID INT,
PRIMARY KEY(EMPLOYEE_ID)
);

INSERT IGNORE INTO EMPLOYEE VALUES (1,8),
(2,8),
(3,8),
(4,7),
(5,9),
(6,9);

SELECT * FROM EMPLOYEE;

-- 21) Write an SQL query to find the team size of each of the employees.
SELECT EMPLOYEE_ID, COUNT(TEAM_ID) OVER (PARTITION BY TEAM_ID) AS TEAM_SIZE FROM EMPLOYEE ORDER BY EMPLOYEE_ID;

-- DATASET 8
CREATE TABLE IF NOT EXISTS COUNTRIES (
COUNTRY_ID INT,
COUNTRY_NAME VARCHAR(30),
PRIMARY KEY(COUNTRY_ID)
);

CREATE TABLE IF NOT EXISTS WEATHER (
COUNTRY_ID INT,
WEATHER_STATE INT,
`DAY` DATE,
PRIMARY KEY(COUNTRY_ID, `DAY`)
);

INSERT IGNORE INTO COUNTRIES VALUES (2, "USA"),
(3,"AUSTRALIA"),
(7,"PERU"),
(5,"CHINA"),
(8,"MOROCCO"),
(9,"SPAIN");	

INSERT IGNORE INTO WEATHER VALUES (2,15,"2019-11-01"),
(2,12,"2019-10-28"),
(2,12,"2019-10-27"),
(3,-2,"2019-11-10"),
(3,0,"2019-11-11"),
(3,3,"2019-11-12"),
(5,16,"2019-11-07"),
(5,18,"2019-11-09"),
(5,21,"2019-11-23"),
(7,25,"2019-11-28"),
(7,22,"2019-12-01"),
(7,20,"2019-12-02"),
(8,25,"2019-11-05"),
(8,27,"2019-11-15"),
(8,31,"2019-11-25"),
(9,7,"2019-10-23"),
(9,3,"2019-12-23");

SELECT * FROM COUNTRIES;
SELECT * FROM WEATHER;

-- 22) Write an SQL query to find the type of weather in each country for November 2019.
-- The type of weather is:
-- ● Cold if the average weather_state is less than or equal 15,
-- ● Hot if the average weather_state is greater than or equal to 25, and
-- ● Warm otherwise.
-- Return result table in any order.

-- SOLUTION 1
SELECT C.COUNTRY_NAME, 
CASE
	WHEN W.WEATHER_STATE <=15 THEN "COLD"
    WHEN W.WEATHER_STATE >= 25 THEN "HOT"
    ELSE "WARM"
    END AS WEATHER_TYPE
FROM WEATHER W
INNER JOIN
COUNTRIES C
ON (C.COUNTRY_ID = W.COUNTRY_ID)
WHERE LEFT(W.`DAY`, 7) = "2019-11"
GROUP BY COUNTRY_NAME;

-- SOLUTION 2
SELECT COUNTRY_NAME, 
CASE
	WHEN AVG(WEATHER_STATE) <= 15 THEN "COLD"
    WHEN AVG(WEATHER_STATE) >= 25 THEN "HOT"
	ELSE "WARM"
    END AS WEATHER_TYPE
FROM WEATHER 
INNER JOIN COUNTRIES
ON (COUNTRIES.COUNTRY_ID = WEATHER.COUNTRY_ID)
WHERE LEFT(`DAY`, 7) = "2019-11"
GROUP BY COUNTRY_NAME;

-- SOLUTION 3
SELECT C.COUNTRY_NAME,
CASE
	WHEN AVG(W.WEATHER_STATE) <=15 THEN "COLD"
    WHEN AVG(W.WEATHER_STATE) >= 25 THEN "HOT"
    ELSE "WARM"
    END AS WEATHER_TYPE
FROM WEATHER W
INNER JOIN COUNTRIES C
ON (C.COUNTRY_ID = W.COUNTRY_ID)
WHERE W.`DAY` BETWEEN '2019-11-01' AND '2019-11-30'
GROUP BY C.COUNTRY_NAME;

-- DATASET 9
CREATE TABLE IF NOT EXISTS PRICES (
PRODUCT_ID INT,
START_DATE DATE,
END_DATE DATE,
PRICE INT,
PRIMARY KEY(PRODUCT_ID,START_DATE,END_DATE)
);

CREATE TABLE IF NOT EXISTS UNITSSOLD (
PRODUCT_ID INT,
PURCHASE_DATE DATE,
UNITS INT
);

INSERT IGNORE INTO PRICES VALUES (1,"2019-02-17","2019-02-28",5),
(1,"2019-03-01","2019-03-22 ",20),
(2,"2019-02-01","2019-02-20",15),
(2,"2019-02-21","2019-03-31",30);

INSERT IGNORE INTO UNITSSOLD VALUES (1,"2019-02-25",100),
(1,"2019-03-01",15),
(2,"2019-02-10",200),
(2,"2019-03-22",30);

SELECT * FROM PRICES;
SELECT * FROM UNITSSOLD;

-- 23) Write an SQL query to find the average selling price for each product. average_price should be
-- rounded to 2 decimal places.
SELECT P.PRODUCT_ID, ROUND(SUM(P.PRICE * U.UNITS) / SUM(U.UNITS),2) AS AVERAGE_PRICE 
FROM PRICES P INNER JOIN UNITSSOLD U 
ON (P.PRODUCT_ID = U.PRODUCT_ID) AND
	DATEDIFF(U.PURCHASE_DATE, P.START_DATE) >= 0 AND 
	DATEDIFF(P.END_DATE, U.PURCHASE_DATE) >=0
GROUP BY P.PRODUCT_ID;

SELECT U.PURCHASE_DATE, P.START_DATE, DATEDIFF(U.PURCHASE_DATE, P.START_DATE) AS DATE_DIFF FROM PRICES P 
INNER JOIN UNITSSOLD U ON (P.PRODUCT_ID = U.PRODUCT_ID)
SELECT P.END_DATE, U.PURCHASE_DATE, DATEDIFF(P.END_DATE, U.PURCHASE_DATE) AS DATE_DIFF FROM PRICES P 
INNER JOIN UNITSSOLD U ON (P.PRODUCT_ID = U.PRODUCT_ID)

-- DATASET 10
CREATE TABLE IF NOT EXISTS ACTIVITY (
PLAYER_ID INT,
DEVICE_ID INT,
EVENT_DATE DATE,
GAMES_PLAYED INT,
PRIMARY KEY(PLAYER_ID, EVENT_DATE)
);

INSERT IGNORE INTO ACTIVITY VALUES (1,2,"2016-03-01",5),
(1,2,"2016-05-02",6),
(2,3,"2017-06-25",1),
(3,1,"2016-03-02",0),
(3,4,"2018-07-03",5);

SELECT * FROM ACTIVITY;

-- 24) Write an SQL query to report the first login date for each player.
SELECT PLAYER_ID, MIN(EVENT_DATE) AS FIRST_LOGIN FROM ACTIVITY GROUP BY PLAYER_ID;

-- 25) Write an SQL query to report the device that is first logged in for each played
SELECT PLAYER_ID, MIN(DEVICE_ID) AS `DEVICE ID` FROM ACTIVITY GROUP BY PLAYER_ID;

-- DATASET 11
CREATE TABLE IF NOT EXISTS PRODUCTS (
PRODUCT_ID INT,
PRODUCT_NAME VARCHAR(30),
PRODUCT_CATEGORY VARCHAR(30),
PRIMARY KEY(PRODUCT_ID)
);

CREATE TABLE IF NOT EXISTS ORDERS (
PRODUCT_ID INT,
ORDER_DATE DATE,
UNIT INT,
FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCTS (PRODUCT_ID)
);

INSERT IGNORE INTO PRODUCTS VALUES (1,"LEETCODE SOLUTIONS","BOOK"),
(2,"JEWELS OF STRINGOLOGY", "BOOKS"),
(3,"HP","LAPTOP"),
(4,"LENOVO","LAPTOP"),
(5,"LEETCODE KIT","T-SHIRTS");

INSERT IGNORE INTO ORDERS VALUES (1,"2020-02-05",60),
(1,"2020-02-10",70),
(2,"2020-01-18",30),
(2,"2020-02-11",80),
(3,"2020-02-17",2),
(3,"2020-02-24",3),
(4,"2020-03-01",20),
(4,"2020-03-04",30),
(4,"2020-03-04",60),
(5,"2020-02-25",50),
(5,"2020-02-27",50),
(5,"2020-03-01",50);

SELECT * FROM PRODUCTS;
SELECT * FROM ORDERS;

-- 26) Write an SQL query to get the names of products that have at least 100 units ordered in February 2020
-- and their amount.
SELECT P.PRODUCT_NAME, SUM(O.UNIT) AS UNIT FROM PRODUCTS P 
LEFT OUTER JOIN ORDERS O
ON (P.PRODUCT_ID = O.PRODUCT_ID)
WHERE O.ORDER_DATE BETWEEN '2020-02-01' AND '2020-02-29'
GROUP BY P.PRODUCT_ID
HAVING SUM(UNIT) >=100;

